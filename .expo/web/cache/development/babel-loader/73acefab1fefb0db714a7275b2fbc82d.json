{"ast":null,"code":"import Animated, { interpolate } from \"react-native-reanimated\";\nimport parseSVG from \"parse-svg-path\";\nimport absSVG from \"abs-svg-path\";\nimport normalizeSVG from \"normalize-svg-path\";\nimport { cartesian2Polar } from \"./Coordinates\";\nimport { cubicBezierYForX } from \"./Math\";\nexport var serialize = function () {\n  var _f = function _f(path) {\n    return \"M\" + path.move.x + \",\" + path.move.y + \" \" + path.curves.map(function (c) {\n      return \"C\" + c.c1.x + \",\" + c.c1.y + \" \" + c.c2.x + \",\" + c.c2.y + \" \" + c.to.x + \",\" + c.to.y;\n    }).join(\" \") + (path.close ? \"Z\" : \"\");\n  };\n\n  _f._closure = {};\n  _f.asString = \"function serialize(path){return\\\"M\\\"+path.move.x+\\\",\\\"+path.move.y+\\\" \\\"+path.curves.map(function(c){return\\\"C\\\"+c.c1.x+\\\",\\\"+c.c1.y+\\\" \\\"+c.c2.x+\\\",\\\"+c.c2.y+\\\" \\\"+c.to.x+\\\",\\\"+c.to.y;}).join(\\\" \\\")+(path.close?\\\"Z\\\":\\\"\\\");}\";\n  _f.__workletHash = 6511175714632;\n  _f.__location = \"C:\\\\Users\\\\MENO\\\\Desktop\\\\PROJECT\\\\APP-DECO-COLOR\\\\deco-color-driver\\\\node_modules\\\\react-native-redash\\\\lib\\\\module\\\\Paths.js (1:275)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\nexport var parse = function parse(d) {\n  var segments = normalizeSVG(absSVG(parseSVG(d)));\n  var path = createPath({\n    x: segments[0][1],\n    y: segments[0][2]\n  });\n  segments.forEach(function (segment) {\n    if (segment[0] === \"Z\") {\n      close(path);\n    } else if (segment[0] === \"C\") {\n      addCurve(path, {\n        c1: {\n          x: segment[1],\n          y: segment[2]\n        },\n        c2: {\n          x: segment[3],\n          y: segment[4]\n        },\n        to: {\n          x: segment[5],\n          y: segment[6]\n        }\n      });\n    }\n  });\n  return path;\n};\nexport var interpolatePath = function () {\n  var _f = function _f(value, inputRange, outputRange) {\n    var extrapolate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Animated.Extrapolate.CLAMP;\n    var path = {\n      move: {\n        x: interpolate(value, inputRange, outputRange.map(function (p) {\n          return p.move.x;\n        }), extrapolate),\n        y: interpolate(value, inputRange, outputRange.map(function (p) {\n          return p.move.y;\n        }), extrapolate)\n      },\n      curves: outputRange[0].curves.map(function (_, index) {\n        return {\n          c1: {\n            x: interpolate(value, inputRange, outputRange.map(function (p) {\n              return p.curves[index].c1.x;\n            }), extrapolate),\n            y: interpolate(value, inputRange, outputRange.map(function (p) {\n              return p.curves[index].c1.y;\n            }), extrapolate)\n          },\n          c2: {\n            x: interpolate(value, inputRange, outputRange.map(function (p) {\n              return p.curves[index].c2.x;\n            }), extrapolate),\n            y: interpolate(value, inputRange, outputRange.map(function (p) {\n              return p.curves[index].c2.y;\n            }), extrapolate)\n          },\n          to: {\n            x: interpolate(value, inputRange, outputRange.map(function (p) {\n              return p.curves[index].to.x;\n            }), extrapolate),\n            y: interpolate(value, inputRange, outputRange.map(function (p) {\n              return p.curves[index].to.y;\n            }), extrapolate)\n          }\n        };\n      }),\n      close: outputRange[0].close\n    };\n    return serialize(path);\n  };\n\n  _f._closure = {\n    Animated: {\n      Extrapolate: {\n        CLAMP: Animated.Extrapolate.CLAMP\n      }\n    },\n    interpolate: interpolate,\n    serialize: serialize\n  };\n  _f.asString = \"function interpolatePath(value,inputRange,outputRange){const{Animated,interpolate,serialize}=jsThis._closure;{var extrapolate=arguments.length>3&&arguments[3]!==undefined?arguments[3]:Animated.Extrapolate.CLAMP;var path={move:{x:interpolate(value,inputRange,outputRange.map(function(p){return p.move.x;}),extrapolate),y:interpolate(value,inputRange,outputRange.map(function(p){return p.move.y;}),extrapolate)},curves:outputRange[0].curves.map(function(_,index){return{c1:{x:interpolate(value,inputRange,outputRange.map(function(p){return p.curves[index].c1.x;}),extrapolate),y:interpolate(value,inputRange,outputRange.map(function(p){return p.curves[index].c1.y;}),extrapolate)},c2:{x:interpolate(value,inputRange,outputRange.map(function(p){return p.curves[index].c2.x;}),extrapolate),y:interpolate(value,inputRange,outputRange.map(function(p){return p.curves[index].c2.y;}),extrapolate)},to:{x:interpolate(value,inputRange,outputRange.map(function(p){return p.curves[index].to.x;}),extrapolate),y:interpolate(value,inputRange,outputRange.map(function(p){return p.curves[index].to.y;}),extrapolate)}};}),close:outputRange[0].close};return serialize(path);}}\";\n  _f.__workletHash = 2067999254256;\n  _f.__location = \"C:\\\\Users\\\\MENO\\\\Desktop\\\\PROJECT\\\\APP-DECO-COLOR\\\\deco-color-driver\\\\node_modules\\\\react-native-redash\\\\lib\\\\module\\\\Paths.js (1:876)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\nexport var mixPath = function () {\n  var _f = function _f(value, p1, p2) {\n    var extrapolate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Animated.Extrapolate.CLAMP;\n    return interpolatePath(value, [0, 1], [p1, p2], extrapolate);\n  };\n\n  _f._closure = {\n    Animated: {\n      Extrapolate: {\n        CLAMP: Animated.Extrapolate.CLAMP\n      }\n    },\n    interpolatePath: interpolatePath\n  };\n  _f.asString = \"function mixPath(value,p1,p2){const{Animated,interpolatePath}=jsThis._closure;{var extrapolate=arguments.length>3&&arguments[3]!==undefined?arguments[3]:Animated.Extrapolate.CLAMP;return interpolatePath(value,[0,1],[p1,p2],extrapolate);}}\";\n  _f.__workletHash = 1615030869398;\n  _f.__location = \"C:\\\\Users\\\\MENO\\\\Desktop\\\\PROJECT\\\\APP-DECO-COLOR\\\\deco-color-driver\\\\node_modules\\\\react-native-redash\\\\lib\\\\module\\\\Paths.js (1:2008)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\nexport var createPath = function () {\n  var _f = function _f(move) {\n    return {\n      move: move,\n      curves: [],\n      close: false\n    };\n  };\n\n  _f._closure = {};\n  _f.asString = \"function createPath(move){return{move:move,curves:[],close:false};}\";\n  _f.__workletHash = 14928498416510;\n  _f.__location = \"C:\\\\Users\\\\MENO\\\\Desktop\\\\PROJECT\\\\APP-DECO-COLOR\\\\deco-color-driver\\\\node_modules\\\\react-native-redash\\\\lib\\\\module\\\\Paths.js (1:2229)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\nexport var addArc = function () {\n  var _f = function _f(path, corner, to) {\n    var last = path.curves[path.curves.length - 1];\n    var from = last ? last.to : path.move;\n    var arc = 9 / 16;\n    path.curves.push({\n      c1: {\n        x: (corner.x - from.x) * arc + from.x,\n        y: (corner.y - from.y) * arc + from.y\n      },\n      c2: {\n        x: (corner.x - to.x) * arc + to.x,\n        y: (corner.y - to.y) * arc + to.y\n      },\n      to: to\n    });\n  };\n\n  _f._closure = {};\n  _f.asString = \"function addArc(path,corner,to){var last=path.curves[path.curves.length-1];var from=last?last.to:path.move;var arc=9/16;path.curves.push({c1:{x:(corner.x-from.x)*arc+from.x,y:(corner.y-from.y)*arc+from.y},c2:{x:(corner.x-to.x)*arc+to.x,y:(corner.y-to.y)*arc+to.y},to:to});}\";\n  _f.__workletHash = 7717658052260;\n  _f.__location = \"C:\\\\Users\\\\MENO\\\\Desktop\\\\PROJECT\\\\APP-DECO-COLOR\\\\deco-color-driver\\\\node_modules\\\\react-native-redash\\\\lib\\\\module\\\\Paths.js (1:2325)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\nexport var addCurve = function () {\n  var _f = function _f(path, c) {\n    path.curves.push({\n      c1: c.c1,\n      c2: c.c2,\n      to: c.to\n    });\n  };\n\n  _f._closure = {};\n  _f.asString = \"function addCurve(path,c){path.curves.push({c1:c.c1,c2:c.c2,to:c.to});}\";\n  _f.__workletHash = 12524308058506;\n  _f.__location = \"C:\\\\Users\\\\MENO\\\\Desktop\\\\PROJECT\\\\APP-DECO-COLOR\\\\deco-color-driver\\\\node_modules\\\\react-native-redash\\\\lib\\\\module\\\\Paths.js (1:2629)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\nexport var addLine = function () {\n  var _f = function _f(path, to) {\n    var last = path.curves[path.curves.length - 1];\n    var from = last ? last.to : path.move;\n    path.curves.push({\n      c1: from,\n      c2: to,\n      to: to\n    });\n  };\n\n  _f._closure = {};\n  _f.asString = \"function addLine(path,to){var last=path.curves[path.curves.length-1];var from=last?last.to:path.move;path.curves.push({c1:from,c2:to,to:to});}\";\n  _f.__workletHash = 4466488744766;\n  _f.__location = \"C:\\\\Users\\\\MENO\\\\Desktop\\\\PROJECT\\\\APP-DECO-COLOR\\\\deco-color-driver\\\\node_modules\\\\react-native-redash\\\\lib\\\\module\\\\Paths.js (1:2730)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\nexport var addQuadraticCurve = function () {\n  var _f = function _f(path, cp, to) {\n    var last = path.curves[path.curves.length - 1];\n    var from = last ? last.to : path.move;\n    path.curves.push({\n      c1: {\n        x: from.x / 3 + 2 / 3 * cp.x,\n        y: from.y / 3 + 2 / 3 * cp.y\n      },\n      c2: {\n        x: to.x / 3 + 2 / 3 * cp.x,\n        y: to.y / 3 + 2 / 3 * cp.y\n      },\n      to: to\n    });\n  };\n\n  _f._closure = {};\n  _f.asString = \"function addQuadraticCurve(path,cp,to){var last=path.curves[path.curves.length-1];var from=last?last.to:path.move;path.curves.push({c1:{x:from.x/3+2/3*cp.x,y:from.y/3+2/3*cp.y},c2:{x:to.x/3+2/3*cp.x,y:to.y/3+2/3*cp.y},to:to});}\";\n  _f.__workletHash = 15214855098425;\n  _f.__location = \"C:\\\\Users\\\\MENO\\\\Desktop\\\\PROJECT\\\\APP-DECO-COLOR\\\\deco-color-driver\\\\node_modules\\\\react-native-redash\\\\lib\\\\module\\\\Paths.js (1:2912)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\nexport var close = function () {\n  var _f = function _f(path) {\n    path.close = true;\n  };\n\n  _f._closure = {};\n  _f.asString = \"function close(path){path.close=true;}\";\n  _f.__workletHash = 6388902332060;\n  _f.__location = \"C:\\\\Users\\\\MENO\\\\Desktop\\\\PROJECT\\\\APP-DECO-COLOR\\\\deco-color-driver\\\\node_modules\\\\react-native-redash\\\\lib\\\\module\\\\Paths.js (1:3167)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nvar curveIsFound = function () {\n  var _f = function _f(c) {\n    return c.curve !== null;\n  };\n\n  _f._closure = {};\n  _f.asString = \"function curveIsFound(c){return c.curve!==null;}\";\n  _f.__workletHash = 16087677445003;\n  _f.__location = \"C:\\\\Users\\\\MENO\\\\Desktop\\\\PROJECT\\\\APP-DECO-COLOR\\\\deco-color-driver\\\\node_modules\\\\react-native-redash\\\\lib\\\\module\\\\Paths.js (1:3233)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nexport var selectCurve = function () {\n  var _f = function _f(path, x) {\n    var result = {\n      from: path.move,\n      curve: null\n    };\n\n    for (var i = 0; i < path.curves.length; i++) {\n      var c = path.curves[i];\n      var contains = result.from.x > c.to.x ? x >= c.to.x && x <= result.from.x : x >= result.from.x && x <= c.to.x;\n\n      if (contains) {\n        result.curve = c;\n        break;\n      }\n\n      result.from = c.to;\n    }\n\n    if (!curveIsFound(result)) {\n      return null;\n    }\n\n    return result;\n  };\n\n  _f._closure = {\n    curveIsFound: curveIsFound\n  };\n  _f.asString = \"function selectCurve(path,x){const{curveIsFound}=jsThis._closure;{var result={from:path.move,curve:null};for(var i=0;i<path.curves.length;i++){var c=path.curves[i];var contains=result.from.x>c.to.x?x>=c.to.x&&x<=result.from.x:x>=result.from.x&&x<=c.to.x;if(contains){result.curve=c;break;}result.from=c.to;}if(!curveIsFound(result)){return null;}return result;}}\";\n  _f.__workletHash = 9727387309432;\n  _f.__location = \"C:\\\\Users\\\\MENO\\\\Desktop\\\\PROJECT\\\\APP-DECO-COLOR\\\\deco-color-driver\\\\node_modules\\\\react-native-redash\\\\lib\\\\module\\\\Paths.js (1:3315)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\nexport var getYForX = function () {\n  var _f = function _f(path, x) {\n    var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n    var c = selectCurve(path, x);\n\n    if (c === null) {\n      return null;\n    }\n\n    return cubicBezierYForX(x, c.from, c.curve.c1, c.curve.c2, c.curve.to, precision);\n  };\n\n  _f._closure = {\n    selectCurve: selectCurve,\n    cubicBezierYForX: cubicBezierYForX\n  };\n  _f.asString = \"function getYForX(path,x){const{selectCurve,cubicBezierYForX}=jsThis._closure;{var precision=arguments.length>2&&arguments[2]!==undefined?arguments[2]:2;var c=selectCurve(path,x);if(c===null){return null;}return cubicBezierYForX(x,c.from,c.curve.c1,c.curve.c2,c.curve.to,precision);}}\";\n  _f.__workletHash = 13044703911450;\n  _f.__location = \"C:\\\\Users\\\\MENO\\\\Desktop\\\\PROJECT\\\\APP-DECO-COLOR\\\\deco-color-driver\\\\node_modules\\\\react-native-redash\\\\lib\\\\module\\\\Paths.js (1:3670)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nvar controlPoint = function () {\n  var _f = function _f(current, previous, next, reverse, smoothing) {\n    var p = previous || current;\n    var n = next || current;\n    var lengthX = n.x - p.x;\n    var lengthY = n.y - p.y;\n    var o = cartesian2Polar({\n      x: lengthX,\n      y: lengthY\n    });\n    var angle = o.theta + (reverse ? Math.PI : 0);\n    var length = o.radius * smoothing;\n    var x = current.x + Math.cos(angle) * length;\n    var y = current.y + Math.sin(angle) * length;\n    return {\n      x: x,\n      y: y\n    };\n  };\n\n  _f._closure = {\n    cartesian2Polar: cartesian2Polar\n  };\n  _f.asString = \"function controlPoint(current,previous,next,reverse,smoothing){const{cartesian2Polar}=jsThis._closure;{var p=previous||current;var n=next||current;var lengthX=n.x-p.x;var lengthY=n.y-p.y;var o=cartesian2Polar({x:lengthX,y:lengthY});var angle=o.theta+(reverse?Math.PI:0);var length=o.radius*smoothing;var x=current.x+Math.cos(angle)*length;var y=current.y+Math.sin(angle)*length;return{x:x,y:y};}}\";\n  _f.__workletHash = 6183874827311;\n  _f.__location = \"C:\\\\Users\\\\MENO\\\\Desktop\\\\PROJECT\\\\APP-DECO-COLOR\\\\deco-color-driver\\\\node_modules\\\\react-native-redash\\\\lib\\\\module\\\\Paths.js (1:3928)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nvar exhaustiveCheck = function exhaustiveCheck(a) {\n  throw new Error(\"Unexhaustive handling for \" + a);\n};\n\nexport var curveLines = function () {\n  var _f = function _f(points, smoothing, strategy) {\n    var path = createPath(points[0]);\n\n    for (var i = 0; i < points.length; i++) {\n      if (i === 0) {\n        continue;\n      }\n\n      var point = points[i];\n      var next = points[i + 1];\n      var prev = points[i - 1];\n      var cps = controlPoint(prev, points[i - 2], point, false, smoothing);\n      var cpe = controlPoint(point, prev, next, true, smoothing);\n\n      switch (strategy) {\n        case \"simple\":\n          var cp = {\n            x: (cps.x + cpe.x) / 2,\n            y: (cps.y + cpe.y) / 2\n          };\n          addQuadraticCurve(path, cp, point);\n          break;\n\n        case \"bezier\":\n          var p0 = points[i - 2] || prev;\n          var p1 = points[i - 1];\n          var cp1x = (2 * p0.x + p1.x) / 3;\n          var cp1y = (2 * p0.y + p1.y) / 3;\n          var cp2x = (p0.x + 2 * p1.x) / 3;\n          var cp2y = (p0.y + 2 * p1.y) / 3;\n          var cp3x = (p0.x + 4 * p1.x + point.x) / 6;\n          var cp3y = (p0.y + 4 * p1.y + point.y) / 6;\n          path.curves.push({\n            c1: {\n              x: cp1x,\n              y: cp1y\n            },\n            c2: {\n              x: cp2x,\n              y: cp2y\n            },\n            to: {\n              x: cp3x,\n              y: cp3y\n            }\n          });\n\n          if (i === points.length - 1) {\n            path.curves.push({\n              to: points[points.length - 1],\n              c1: points[points.length - 1],\n              c2: points[points.length - 1]\n            });\n          }\n\n          break;\n\n        case \"complex\":\n          path.curves.push({\n            to: point,\n            c1: cps,\n            c2: cpe\n          });\n          break;\n\n        default:\n          exhaustiveCheck(strategy);\n      }\n    }\n\n    return path;\n  };\n\n  _f._closure = {\n    createPath: createPath,\n    controlPoint: controlPoint,\n    addQuadraticCurve: addQuadraticCurve,\n    exhaustiveCheck: exhaustiveCheck\n  };\n  _f.asString = \"function curveLines(points,smoothing,strategy){const{createPath,controlPoint,addQuadraticCurve,exhaustiveCheck}=jsThis._closure;{var path=createPath(points[0]);for(var i=0;i<points.length;i++){if(i===0){continue;}var point=points[i];var next=points[i+1];var prev=points[i-1];var cps=controlPoint(prev,points[i-2],point,false,smoothing);var cpe=controlPoint(point,prev,next,true,smoothing);switch(strategy){case\\\"simple\\\":var cp={x:(cps.x+cpe.x)/2,y:(cps.y+cpe.y)/2};addQuadraticCurve(path,cp,point);break;case\\\"bezier\\\":var p0=points[i-2]||prev;var p1=points[i-1];var cp1x=(2*p0.x+p1.x)/3;var cp1y=(2*p0.y+p1.y)/3;var cp2x=(p0.x+2*p1.x)/3;var cp2y=(p0.y+2*p1.y)/3;var cp3x=(p0.x+4*p1.x+point.x)/6;var cp3y=(p0.y+4*p1.y+point.y)/6;path.curves.push({c1:{x:cp1x,y:cp1y},c2:{x:cp2x,y:cp2y},to:{x:cp3x,y:cp3y}});if(i===points.length-1){path.curves.push({to:points[points.length-1],c1:points[points.length-1],c2:points[points.length-1]});}break;case\\\"complex\\\":path.curves.push({to:point,c1:cps,c2:cpe});break;default:exhaustiveCheck(strategy);}}return path;}}\";\n  _f.__workletHash = 4521352181802;\n  _f.__location = \"C:\\\\Users\\\\MENO\\\\Desktop\\\\PROJECT\\\\APP-DECO-COLOR\\\\deco-color-driver\\\\node_modules\\\\react-native-redash\\\\lib\\\\module\\\\Paths.js (1:4414)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();","map":{"version":3,"mappings":"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","names":["Animated","interpolate","parseSVG","absSVG","normalizeSVG","cartesian2Polar","cubicBezierYForX","serialize","path","move","x","y","curves","map","c","c1","c2","to","join","close","parse","d","segments","createPath","forEach","segment","addCurve","interpolatePath","value","inputRange","outputRange","extrapolate","Extrapolate","CLAMP","p","_","index","mixPath","p1","p2","addArc","corner","last","length","from","arc","push","addLine","addQuadraticCurve","cp","curveIsFound","curve","selectCurve","result","i","contains","getYForX","precision","controlPoint","current","previous","next","reverse","smoothing","n","lengthX","lengthY","o","angle","theta","Math","PI","radius","cos","sin","exhaustiveCheck","a","Error","curveLines","points","strategy","point","prev","cps","cpe","p0","cp1x","cp1y","cp2x","cp2y","cp3x","cp3y"],"sources":["Paths.ts"],"sourcesContent":["import Animated, { interpolate } from \"react-native-reanimated\";\nimport parseSVG from \"parse-svg-path\";\nimport absSVG from \"abs-svg-path\";\nimport normalizeSVG from \"normalize-svg-path\";\n\nimport type { Vector } from \"./Vectors\";\nimport { cartesian2Polar } from \"./Coordinates\";\nimport { cubicBezierYForX } from \"./Math\";\n\ntype SVGCloseCommand = [\"Z\"];\ntype SVGMoveCommand = [\"M\", number, number];\ntype SVGCurveCommand = [\"C\", number, number, number, number, number, number];\ntype SVGNormalizedCommands = [\n  SVGMoveCommand,\n  ...(SVGCurveCommand | SVGCloseCommand)[]\n];\n\ninterface Curve {\n  to: Vector;\n  c1: Vector;\n  c2: Vector;\n}\n\nexport type Path = {\n  move: Vector;\n  curves: Curve[];\n  close: boolean;\n};\n\n/**\n * @summary Serialize a path into an SVG path string\n * @worklet\n */\nexport const serialize = (path: Path) => {\n  \"worklet\";\n  return `M${path.move.x},${path.move.y} ${path.curves\n    .map((c) => `C${c.c1.x},${c.c1.y} ${c.c2.x},${c.c2.y} ${c.to.x},${c.to.y}`)\n    .join(\" \")}${path.close ? \"Z\" : \"\"}`;\n};\n\n/**\n * @description ⚠️ this function cannot run on the UI thread. It must be executed on the JS thread\n * @summary Parse an SVG path into a sequence of Bèzier curves.\n * The SVG is normalized to have absolute values and to be approximated to a sequence of Bèzier curves.\n */\nexport const parse = (d: string): Path => {\n  const segments: SVGNormalizedCommands = normalizeSVG(absSVG(parseSVG(d)));\n  const path = createPath({ x: segments[0][1], y: segments[0][2] });\n  segments.forEach((segment) => {\n    if (segment[0] === \"Z\") {\n      close(path);\n    } else if (segment[0] === \"C\") {\n      addCurve(path, {\n        c1: {\n          x: segment[1],\n          y: segment[2],\n        },\n        c2: {\n          x: segment[3],\n          y: segment[4],\n        },\n        to: {\n          x: segment[5],\n          y: segment[6],\n        },\n      });\n    }\n  });\n  return path;\n};\n\n/**\n * @summary Interpolate between paths.\n * @worklet\n */\nexport const interpolatePath = (\n  value: number,\n  inputRange: number[],\n  outputRange: Path[],\n  extrapolate = Animated.Extrapolate.CLAMP\n) => {\n  \"worklet\";\n  const path = {\n    move: {\n      x: interpolate(\n        value,\n        inputRange,\n        outputRange.map((p) => p.move.x),\n        extrapolate\n      ),\n      y: interpolate(\n        value,\n        inputRange,\n        outputRange.map((p) => p.move.y),\n        extrapolate\n      ),\n    },\n    curves: outputRange[0].curves.map((_, index) => ({\n      c1: {\n        x: interpolate(\n          value,\n          inputRange,\n          outputRange.map((p) => p.curves[index].c1.x),\n          extrapolate\n        ),\n        y: interpolate(\n          value,\n          inputRange,\n          outputRange.map((p) => p.curves[index].c1.y),\n          extrapolate\n        ),\n      },\n      c2: {\n        x: interpolate(\n          value,\n          inputRange,\n          outputRange.map((p) => p.curves[index].c2.x),\n          extrapolate\n        ),\n        y: interpolate(\n          value,\n          inputRange,\n          outputRange.map((p) => p.curves[index].c2.y),\n          extrapolate\n        ),\n      },\n      to: {\n        x: interpolate(\n          value,\n          inputRange,\n          outputRange.map((p) => p.curves[index].to.x),\n          extrapolate\n        ),\n        y: interpolate(\n          value,\n          inputRange,\n          outputRange.map((p) => p.curves[index].to.y),\n          extrapolate\n        ),\n      },\n    })),\n    close: outputRange[0].close,\n  };\n  return serialize(path);\n};\n\n/**\n * @summary Interpolate two paths with an animation value that goes from 0 to 1\n * @worklet\n */\nexport const mixPath = (\n  value: number,\n  p1: Path,\n  p2: Path,\n  extrapolate = Animated.Extrapolate.CLAMP\n) => {\n  \"worklet\";\n  return interpolatePath(value, [0, 1], [p1, p2], extrapolate);\n};\n\n/**\n * @summary Create a new path\n * @worklet\n */\nexport const createPath = (move: Vector): Path => {\n  \"worklet\";\n  return {\n    move,\n    curves: [],\n    close: false,\n  };\n};\n\n/**\n * @summary Add an arc command to a path\n * @worklet\n */\nexport const addArc = (path: Path, corner: Vector, to: Vector) => {\n  \"worklet\";\n  const last = path.curves[path.curves.length - 1];\n  const from = last ? last.to : path.move;\n  const arc = 9 / 16;\n  path.curves.push({\n    c1: {\n      x: (corner.x - from.x) * arc + from.x,\n      y: (corner.y - from.y) * arc + from.y,\n    },\n    c2: {\n      x: (corner.x - to.x) * arc + to.x,\n      y: (corner.y - to.y) * arc + to.y,\n    },\n    to,\n  });\n};\n\n/**\n * @summary Add a cubic Bèzier curve command to a path.\n * @worklet\n */\nexport const addCurve = (path: Path, c: Curve) => {\n  \"worklet\";\n  path.curves.push({\n    c1: c.c1,\n    c2: c.c2,\n    to: c.to,\n  });\n};\n\n/**\n * @summary Add a line command to a path.\n * @worklet\n */\nexport const addLine = (path: Path, to: Vector) => {\n  \"worklet\";\n  const last = path.curves[path.curves.length - 1];\n  const from = last ? last.to : path.move;\n  path.curves.push({\n    c1: from,\n    c2: to,\n    to,\n  });\n};\n\n/**\n * @summary Add a quadratic Bèzier curve command to a path.\n * @worklet\n */\nexport const addQuadraticCurve = (path: Path, cp: Vector, to: Vector) => {\n  \"worklet\";\n  const last = path.curves[path.curves.length - 1];\n  const from = last ? last.to : path.move;\n  path.curves.push({\n    c1: {\n      x: from.x / 3 + (2 / 3) * cp.x,\n      y: from.y / 3 + (2 / 3) * cp.y,\n    },\n    c2: {\n      x: to.x / 3 + (2 / 3) * cp.x,\n      y: to.y / 3 + (2 / 3) * cp.y,\n    },\n    to,\n  });\n};\n\n/**\n * @summary Add a close command to a path.\n * @worklet\n */\nexport const close = (path: Path) => {\n  \"worklet\";\n  path.close = true;\n};\n\ninterface SelectedCurve {\n  from: Vector;\n  curve: Curve;\n}\n\ninterface NullableSelectedCurve {\n  from: Vector;\n  curve: Curve | null;\n}\n\n/**\n * @worklet\n */\nconst curveIsFound = (c: NullableSelectedCurve): c is SelectedCurve => {\n  \"worklet\";\n  return c.curve !== null;\n};\n\n/**\n * @summary Return the curves at x. This function assumes that only one curve is available at x\n * @worklet\n */\nexport const selectCurve = (path: Path, x: number): SelectedCurve | null => {\n  \"worklet\";\n  const result: NullableSelectedCurve = {\n    from: path.move,\n    curve: null,\n  };\n  for (let i = 0; i < path.curves.length; i++) {\n    const c = path.curves[i];\n    const contains =\n      result.from.x > c.to.x\n        ? x >= c.to.x && x <= result.from.x\n        : x >= result.from.x && x <= c.to.x;\n    if (contains) {\n      result.curve = c;\n      break;\n    }\n    result.from = c.to;\n  }\n  if (!curveIsFound(result)) {\n    return null;\n  }\n  return result;\n};\n\n/**\n * @summary Return the y value of a path given its x coordinate\n * @example\n    const p1 = parse(\n      \"M150,0 C150,0 0,75 200,75 C75,200 200,225 200,225 C225,200 200,150 0,150\"\n    );\n    // 75\n    getYForX(p1, 200))\n    // ~151\n    getYForX(p1, 50)\n * @worklet\n */\nexport const getYForX = (path: Path, x: number, precision = 2) => {\n  \"worklet\";\n  const c = selectCurve(path, x);\n  if (c === null) {\n    return null;\n  }\n  return cubicBezierYForX(\n    x,\n    c.from,\n    c.curve.c1,\n    c.curve.c2,\n    c.curve.to,\n    precision\n  );\n};\n\nconst controlPoint = (\n  current: Vector,\n  previous: Vector,\n  next: Vector,\n  reverse: boolean,\n  smoothing: number\n) => {\n  \"worklet\";\n  const p = previous || current;\n  const n = next || current;\n  // Properties of the opposed-line\n  const lengthX = n.x - p.x;\n  const lengthY = n.y - p.y;\n\n  const o = cartesian2Polar({ x: lengthX, y: lengthY });\n  // If is end-control-point, add PI to the angle to go backward\n  const angle = o.theta + (reverse ? Math.PI : 0);\n  const length = o.radius * smoothing;\n  // The control point position is relative to the current point\n  const x = current.x + Math.cos(angle) * length;\n  const y = current.y + Math.sin(angle) * length;\n  return { x, y };\n};\n\nconst exhaustiveCheck = (a: never): never => {\n  throw new Error(`Unexhaustive handling for ${a}`);\n};\n\n/**\n * @summary Link points via a smooth cubic Bézier curves\n * from https://github.com/rainbow-me/rainbow\n * @worklet\n */\nexport const curveLines = (\n  points: Vector<number>[],\n  smoothing: number,\n  strategy: \"complex\" | \"bezier\" | \"simple\"\n) => {\n  \"worklet\";\n  const path = createPath(points[0]);\n  // build the d attributes by looping over the points\n  for (let i = 0; i < points.length; i++) {\n    if (i === 0) {\n      continue;\n    }\n    const point = points[i];\n    const next = points[i + 1];\n    const prev = points[i - 1];\n    const cps = controlPoint(prev, points[i - 2], point, false, smoothing);\n    const cpe = controlPoint(point, prev, next, true, smoothing);\n    switch (strategy) {\n      case \"simple\":\n        const cp = {\n          x: (cps.x + cpe.x) / 2,\n          y: (cps.y + cpe.y) / 2,\n        };\n        addQuadraticCurve(path, cp, point);\n        break;\n      case \"bezier\":\n        const p0 = points[i - 2] || prev;\n        const p1 = points[i - 1];\n        const cp1x = (2 * p0.x + p1.x) / 3;\n        const cp1y = (2 * p0.y + p1.y) / 3;\n        const cp2x = (p0.x + 2 * p1.x) / 3;\n        const cp2y = (p0.y + 2 * p1.y) / 3;\n        const cp3x = (p0.x + 4 * p1.x + point.x) / 6;\n        const cp3y = (p0.y + 4 * p1.y + point.y) / 6;\n        path.curves.push({\n          c1: { x: cp1x, y: cp1y },\n          c2: { x: cp2x, y: cp2y },\n          to: { x: cp3x, y: cp3y },\n        });\n        if (i === points.length - 1) {\n          path.curves.push({\n            to: points[points.length - 1],\n            c1: points[points.length - 1],\n            c2: points[points.length - 1],\n          });\n        }\n        break;\n      case \"complex\":\n        path.curves.push({\n          to: point,\n          c1: cps,\n          c2: cpe,\n        });\n        break;\n      default:\n        exhaustiveCheck(strategy);\n    }\n  }\n  return path;\n};\n"]},"metadata":{},"sourceType":"module"}