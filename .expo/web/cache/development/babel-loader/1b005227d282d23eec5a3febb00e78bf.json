{"ast":null,"code":"export var snapPoint = function () {\n  var _f = function _f(value, velocity, points) {\n    var point = value + 0.2 * velocity;\n    var deltas = points.map(function (p) {\n      return Math.abs(point - p);\n    });\n    var minDelta = Math.min.apply(null, deltas);\n    return points.filter(function (p) {\n      return Math.abs(point - p) === minDelta;\n    })[0];\n  };\n\n  _f._closure = {};\n  _f.asString = \"function snapPoint(value,velocity,points){var point=value+0.2*velocity;var deltas=points.map(function(p){return Math.abs(point-p);});var minDelta=Math.min.apply(null,deltas);return points.filter(function(p){return Math.abs(point-p)===minDelta;})[0];}\";\n  _f.__workletHash = 3848343866657;\n  _f.__location = \"C:\\\\Users\\\\MENO\\\\Desktop\\\\PROJECT\\\\APP-DECO-COLOR\\\\deco-color-driver\\\\node_modules\\\\react-native-redash\\\\lib\\\\module\\\\Physics.js (1:21)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();","map":{"version":3,"mappings":"AAIA,OAAO,IAAMA,SAAS;EAAA,qBACpBC,KADoB,EAEpBC,QAFoB,EAGpBC,MAHoB,EAIT;IAEX,IAAMC,KAAK,GAAGH,KAAK,GAAG,MAAMC,QAA5B;IACA,IAAMG,MAAM,GAAGF,MAAM,CAACG,GAAPH,CAAW,UAACI,CAAD;MAAA,OAAOC,IAAI,CAACC,GAALD,CAASJ,KAAK,GAAGG,CAAjBC,CAAP;IAAX,EAAf;IACA,IAAME,QAAQ,GAAGF,IAAI,CAACG,GAALH,CAASI,KAATJ,CAAe,IAAfA,EAAqBH,MAArBG,CAAjB;IACA,OAAOL,MAAM,CAACU,MAAPV,CAAc,UAACI,CAAD;MAAA,OAAOC,IAAI,CAACC,GAALD,CAASJ,KAAK,GAAGG,CAAjBC,MAAwBE,QAA/B;IAAd,GAAuD,CAAvDP,CAAP;EATK,CAAe;;EAAA;EAAA;EAAA;EAAA;;EAAA;;EAAA;AAAA,GAAf","names":["snapPoint","value","velocity","points","point","deltas","map","p","Math","abs","minDelta","min","apply","filter"],"sources":["Physics.ts"],"sourcesContent":["/**\n * @summary Select a point where the animation should snap to given the value of the gesture and it's velocity.\n * @worklet\n */\nexport const snapPoint = (\n  value: number,\n  velocity: number,\n  points: ReadonlyArray<number>\n): number => {\n  \"worklet\";\n  const point = value + 0.2 * velocity;\n  const deltas = points.map((p) => Math.abs(point - p));\n  const minDelta = Math.min.apply(null, deltas);\n  return points.filter((p) => Math.abs(point - p) === minDelta)[0];\n};\n"]},"metadata":{},"sourceType":"module"}